## OAuth2 Authentication Example

This is the most common authentication, in this scenario the user go to your web page and clicks a login button, then the user is redirected to a authorization agent (like Keycloak) for authentication, when he finish the user is redirected back to your webpage with a token.

### Discovery

OAuth2 specify an auto-discovery URL, in Keycloak this URL are basically built in this form:

```xml
 https://{Server}:{Port}/auth/realms/<your-realm>/.well-known/openid-configuration
```
This URL will return a list of endpoints required to use OAuth2 authentication:

```json

{
  "issuer":"https://my-keycloak-server/auth/realms/demo-1",
  "authorization_endpoint":".../auth",
  "token_endpoint":".../token",
  "token_introspection_endpoint":".../introspect",
  "userinfo_endpoint":".../userinfo",
  "end_session_endpoint":".../logout"
  "etc..."
}
```

### Hello World Nodejs

We can start by making a simple HTTP server using Javascript: 

```sh
 var express = require('express')
 var okd_runner = require('okd-runner')
 var app = express()
 
 app.get('/', (req, res) => res.send('<h1> Hello !</h1>') )

 console.log('listening in port 8080')
 app.listen(8080)
```

We save this into ``index.js``. 


#### Testing Locally

After we save it we need to install two libraries:
 - ``express`` server framework. 
 - ``okd-runner`` make this application self-deployable to OpenShift.  

```sh
 npm install express okd-runner --save
```

Now we can test it locally:

```sh
node index.js
# listening in port 8080
```

### Login Page

Now that we got our server running let's add a small **login** webpage:  

```js
var express = require('express')

var app = express()
const PORT = 8080

function askForCredentials({URL}) {
    return `<!DOCTYPE HTML>
            <html>
              <head>
                <title>Hello OAuth2</title>
              </head>
              <body>
                <h1> Register </h1>
                <a href="${URL}">Login</a>
              </body>
            </html>`
}

app.get('/', (req, res) => {
  let page = buildLoginPage({ URL: 'http://test.com' })
  res.send(page)
})
```

If we run our server again we should see a nice login page. 

![Login Page](https://github.com/cesarvr/keycloak-examples/blob/master/web-ui/docs/login.png?raw=true)



### Asking For Authorization 

Now we need to delegate the authentication process to RedHat SSO, after all we don't want our service to know anything about this, so we can achieve this by redirecting the user via our **login** page to an especific kecloak endpoint called ``authorization_endpoint``, you can find this endpoint in the [discovery payload](https://github.com/cesarvr/keycloak-examples/tree/master/web-ui#discovery). 

We need to call this URL like this:

```
 https://my-keycloak-server/auth/realms/demo-1/protocol/openid-connect/auth?response_type=...
```

With this [query parameters](https://en.wikipedia.org/wiki/Query_string):

```xml
...auth?response_type=code
 &client_id=my-client
 &redirect_uri=https%3A%2F%2Flocalhost%3A666%2F
 &scope=my-scope
 &state=state123
```

Where:
- **response_type**=code - Indicates that your server expects to receive an authorization code
- **client_id** - You need to [register a client in RHSSO](https://www.keycloak.org/docs/latest/getting_started/index.html#creating-and-registering-the-client), usually the name of the client is the client ID.

![](https://www.keycloak.org/docs/latest/getting_started/keycloak-images/clients.png)
- **redirect_uri** - Indicates the URI to return the user to after authorization is complete, make sure you set the right redirect address for your [client](https://www.keycloak.org/docs/latest/getting_started/index.html#creating-and-registering-the-client).

![](https://i.stack.imgur.com/IMEhn.png)

> Arterisk (*), means that we accept any URL pattern as redirect URI. 

- **scope** - One or more scope values indicating which parts of the user's account you wish to access
- **state** - A random string generated by your application, which you'll verify later to be sure your service is the initiator of this request. 


Let's write a function that generate this link for us:

```js
let qs  = require('querystring')

function buildURL() {

    const realm = 'demo-1'

    let params = qs.stringify({
        response_type: 'code',
        client_id: 'my-client',
        scope: 'photos',
        state: 'state123',
        redirect_uri: 'http://localhost:8080'
    })

    return `https://my-keycloak-server/auth/realms/${realm}/protocol/openid-connect/auth?${params}`
}
```

This function will craft an URL, so now let's pass this URL to our **login** screen link: 

```sh
app.get('/', (req, res) => {
  let page = buildLoginPage({ URL:  buildURL() })
  res.send(page)
})
```

Now we execute our server again: 

We are going to see our Login page: 

![Login Page](https://github.com/cesarvr/keycloak-examples/blob/master/web-ui/docs/login.png?raw=true)

But if we click we are going to get redirected to: 

![keycloak](https://github.com/cesarvr/keycloak-examples/blob/master/docs/Screenshot%202019-05-03%20at%2012.42.30.png?raw=true)

This is the Red Hat SSO login page for this realm. 

## Handling Responses

Once the user finish the authentication the Keycloak server following the OAuth2 protocol wil use the value of ``redirect_uri`` to call us back, the problem is that this only work is our application is visible, to do that let's assume we have a OpenShift cluster running in the cloud, so let's proceed to deploy our application.


### Deploying To OpenShift

To deploy to OpenShift is very simple we just need to add a library called [okd-runner](https://www.npmjs.com/package/okd-runner):

```sh
npm install okd-runner --save
```

Add the library:

```js
let okd = require('okd-runner')
```

That's it, now your applications should know how to deploy itself, now you just need to execute:

```sh
node index.js --deploy --memory 80
▶ node index.js -c
Initializing...  ok
creating objects  ok
building  ok

   URL:  http://web-auth-testing-1.apps.my-openshift-cluster.com
   ....
   ....
   > web-auth@1.0.0 start /opt/app-root/src
   > node index.js

   listening for request in 8080
```
This will handle the hassle for us and will put a container with 80 MB of ram in OpenShift ready to receive traffic.


### Configuring Callback

Once your application is deployed you will get back the route URL in this case ``http://web-auth-testing-1.apps.my-openshift-cluster.com`` this is the HTTP access point for our container, we can hit this URL with the browser. Now to configure our service so it send this route as the part of the authentication. 

Let's pick our URL generator function and make the ``redirect_uri`` field adquire this value from the environment variables: 

```js
function buildURL() {
    const realm = 'demo-1'

    let params = qs.stringify({
        response_type: 'code',
        client_id: 'my-client',
        scope: 'photos',
        state: 'state123',
        redirect_uri: `${process.env['ROUTE'] || 'URL_NOT_FOUND'}login` // <- Here
    })

    return `https://sso-testing-1.apps.tmagic-5e4a.openshiftworkshop.com/auth/realms/${realm}/protocol/openid-connect/auth?${params}`
}
```

To re-deploy our changes we just do: 


```sh
node index.js --deploy --memory 80  
```

And now we can set that value by navigating the OpenShift Console or using ``oc-client``:


```sh
 oc set env deploy web-auth ROUTE=http://web-auth-testing-1.apps.my-openshift-cluster.com/callback
```

As you might see we are setting a little endpoint ``/callback`` in our URL this is because we still need to manage the response from RH SSO. 

### Handling Callback Data

As mentioned before when the user authenticate against Keycloak, then he will be redirected to our page via ``redirect_uri`` we configure before, our service need to be ready to handle some parameters: 

```sh
https://$ROUTE/callback?code=AUTH_CODE_HERE&state=1234zyx
```

- **code**  The server returns the authorization code.
- **state** The server returns the same state value generated by our service, in this moment we need to validate the state making sure that this state value was generated by us, so we can avoid [man in the middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) type of attack. 


Let's define and endpoint capable of reading this values: 

```js
app.get('/', (req, res) => {...})

app.get('/callback', (req, res) => {
    if(req.query.code)
        //if we got the code we can allow the user to use the service.
        // This is a good place to implement a redirect, passing the token.  
        res.send(`<h2> Access token is ${req.query.code} </h2>`)
    else
        res.state(401).send(`<h2> UNAUTHORIZED </h2>`)
})
```

We redeploy this: 

```sh
node index --deploy --memory 80
```

And after we perform authentication against RH SSO we should get something similar to this: 

![](https://github.com/cesarvr/keycloak-examples/blob/master/docs/Screenshot%202019-05-03%20at%2013.22.44.png?raw=true)


This code represents a sort of public key from the user, now we need to take this public key authenticate our client (our service) against RH SSO, if everything went well we get back an access token that we are going to use to access user resources.


### Exchange Token

The last step is to use this user authorization key we receive in our ``/callback?code=AUTH_CODE_HERE``) and use this to obtain a token, then we can use this token to finally make request.  

```xml
 https://<our-rhsso-instance>/auth/realms/demo-1/protocol/openid-connect/token
```

> We can obtain this URL by reading the ``token_endpoint`` field in the [discovery payload](https://github.com/cesarvr/keycloak-examples/tree/master/web-ui#discovery).

This **POST** request require the following parameters: 

```js
 let params = {
        grant_type: 'authorization_code',
        code: token,
        client_id: 'my-client',
        client_secret: 'a5e98989-afae-45f8-9818-8e6f02eaa2b0', 
        redirect_uri: `${process.env['ROUTE'] || 'URL_NOT_FOUND'}login` 
    }
```

- **auhtorization_code** An authorization grant is a credential representing the resource
   owner's authorization..., [more about authorization grant](https://tools.ietf.org/html/rfc6749#page-8). We use here the ``authorization_code``.
- **code** The token code we receive in the ``/callback``. 
- **client_id** - You need to [register a client in RHSSO](https://www.keycloak.org/docs/latest/getting_started/index.html#creating-and-registering-the-client), usually the name of the client is the client ID.

![](https://www.keycloak.org/docs/latest/getting_started/keycloak-images/clients.png)

- **client_secret** This is an extra security measure is basically a secret code shared between trusted entities, in our case our service and RH SSO. This make it a bit difficult for attacker that one to request this resource. [How configure this ?](https://www.keycloak.org/docs/2.5/server_admin/topics/clients/oidc/confidential.html)

- **redirect_uri** We need the same redirect_uri we send the first time, RH SSO will check this URI in their registry and should match the one that made the initial request.



### Request


To make this **POST** request we are a going to use a Node.js library called [Request](https://www.npmjs.com/package/request) that would take care of the details for us:

We install it doing: 

```sh
npm install request --save
```

Now we write our ``exchange_token`` function by defining the parameters: 

```js
function exchange_token(token) {
 let params = {
        grant_type: 'authorization_code',
        code: token,
        client_id: 'my-client',
        client_secret: 'client-secret-...', 
        redirect_uri: `${process.env['ROUTE'] || 'URL_NOT_FOUND'}login` 
 }
 
}

```

This function is very simple, it receive a token and build the parameters to be submited in the POST request, now let's write this part with using [Request](https://www.npmjs.com/package/request) library: 

```js
let request = require('request')

function exchange_token(token, success, error) { 
 let params = { code: token, /*...* }
 

 request({
    method: 'POST',
    rejectUnauthorized: false,      // For testing only, this will avoid SSL Authentication.
    headers: {
      "content-type": "application/json",
    },
    url: 'https://<our-rhsso-instance>/auth/realms/demo-1/protocol/openid-connect/token',
    form: params,
 }, function(error, resp, body) { 
    if(error){
     console.log('Authentication Error')
     error(401)
    }else {
     console.log('sucess: ', body)
     success(200)
    }
 })
```
Beside the ``token`` parameter we also are going to need two more parameter in ``sucess`` and ``error`` they will work as our [function callbacks](https://www.tutorialspoint.com/nodejs/nodejs_callbacks_concept.htm). 


Now we can go to our ``/callback`` endpoint: 

```js
app.get('/callback', (req, res) => {
    exchange_toke(req.query.code, 
         success => res.state(sucess).send('<h1> Willkommen! </h1>'),
         error => res.state(error).send(`<h2> UNAUTHORIZED </h2>`)
})
```

We redeploy this and we should have our OAuth2 client up and running. 


![](https://github.com/cesarvr/keycloak-examples/blob/master/docs/Screenshot%202019-05-03%20at%2015.10.16.png?raw=true)



If we check the logs we should be able to see something similar to this: 

```sh
▶ node index.js -c
Initializing...  ok
creating objects  ok
building  ok

   URL:  http://web-auth-testing-1.apps.my-openshift-cluster.com
   ....
   ....
   > web-auth@1.0.0 start /opt/app-root/src
   > node index.js
   
   
sucess: {
  "access_token":"RsT5OjbzRn430zqMLgV3a...",
  "expires_in":3600
}

```







